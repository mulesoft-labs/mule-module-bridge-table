/**
 * Mule Development Kit
 * Copyright 2010-2011 (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.module.bridgetable.BridgeTable;
import org.mule.module.bridgetable.BridgeTableFactory;
import org.mule.module.bridgetable.KeyDoesNotExistException;
import org.mule.module.bridgetable.KeyType;
import org.mule.module.bridgetable.Type;

/**
 * <p>
 * This connector offers the functionality of a <b>bridge table</b> (a.k.a. junction table, cross-reference table, join table,
 * map table, intersection table, linking table, many-to-many resolver, link table, pairing table, pivot table,
 * look-up table, or association table) to offer mapping of two values (keys).
 * </p>
 * <p>
 * Basically it supports inserting two keys (key1 and key2) and perform direct and reverse lookups:
 * <ul>
 *      <li>Direct Lookup: Providing key1 you can retrieve the value of key2</li>
 *      <li>Reverse Lookup: Providing key2 you can retrieve the value of key1</li>
 * </ul>
 *</p>
 *<p>
 * <b>The relationship cardinality between key1 and key2 is 1 to 1.</b> This means that there can only be
 * one value of key2 linked to a value of key1 (and vicecersa).
 * </p>
 * <p>
 * The module exposes opertations to insert, update, delete and list keys too.
 * </p>
 * 
 * {@sample.config ../../../doc/module-bridgetable-module.xml.sample bridgetable:config1}
 * 
 * @author MuleSoft, Inc.
 */
@Module(name="bridgetable", schemaVersion="1.0-SNAPSHOT")
public class BridgeTableModule
{
    private static final Logger LOGGER = Logger.getLogger(BridgeTableModule.class);
    
    /**
     * Name of the bridge table. For example if bridge table is implemented in a Database, this will be the
     * name of the relational table
     */
    @Configurable
    private String tableName;

    /**
     * Type or concreate implementation of the bridge table. Supported types are:
     * <ul>
     *    <li>DATA_SOURCE: Implementation that receives a Data Source object and uses Database tables through JDBC</i>
     * </ul>
     */
    @Configurable
    @Optional
    @Default("DEFAULT_VOLATILE")
    private Type type;
    
    /**
     * When the type is <b>DATA_SOURCE</b> this is the reference to the DataSource object that should be pre-configured
     * before it can be used in this module. The name of this attribute is <code>dataSource-ref</code>
     */
    @Configurable
    @Optional
    private DataSource dataSource;

    /**
     * If the bridge table doesn't exist it will be created automatically if this flag is set to <i>true</i>.
     */
    @Configurable
    @Optional
    @Default("false")
    private boolean autoCreateTable;
    
    /**
     * Data type of key1. This will be used to create the correct structure type. For example, if the
     * implementation is done with a database then this attribute will be used to define the correct
     * column type (STRING => varchar)
     */
    @Configurable
    @Optional
    @Default("STRING")
    private KeyType key1Type;

    /**
     * Descriptive name for key1. This value may be used as a database table column name, so it needs
     * to be a valid as so.
     */
    @Configurable
    @Optional
    @Default("key1")
    private String key1Name;

    /**
     * Descriptive name for key2. This value may be used as a database table column name, so it needs
     * to be a valid as so.
     */
    @Configurable
    @Optional
    @Default("key2")
    private String key2Name;
    
    /**
     * Data type of key2. This will be used to create the correct structure type. For example, if the
     * implementation is done with a database then this attribute will be used to define the correct
     * column type (STRING => varchar)
     */
    @Configurable
    @Optional
    @Default("STRING")
    private KeyType key2Type;
    
    /**
     * Whether empty keys are allowed. An empty key is null or the empty string ("").
     */
    @Configurable
    @Optional
    @Default("false")
    private boolean allowEmptyKeys = false;
    
    /**
     * Whether all values should be returned as strings or not.
     */
    @Configurable
    @Optional
    @Default("false")
    private boolean returnValueAsString = false;
    
    // Implementation
    private BridgeTable bridgeTable;
    
    /**
     * Initializes the bridge table component
     * @throws Exception In case of error while initializing the concrete bridge table implementation
     */
    @Start
    public void onStart() throws Exception
    {
        Map<Type, Object> config = new HashMap<Type, Object>();
        config.put(Type.DATA_SOURCE, getDataSource());
        
        this.bridgeTable = BridgeTableFactory.create(type, config);
        this.bridgeTable.init(getTableName(), getKey1Type(), getKey2Type(), getKey1Name(), getKey2Name(), autoCreateTable);
    }
    
    /**
     * Clean up
     * @throws Exception In case of error
     */
    @Stop
    public void onStop() throws Exception
    {
        if(this.bridgeTable != null)
        {
            this.bridgeTable.destroy();
            this.bridgeTable = null;
        }
    }
    
    /**
     * Insert the mapping: key1 <=> key2.
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:insert}
     *
     * @param key1 The value for key1
     * @param key2 The value for key2
     * @throws KeyAlreadyExistsException If key1 or key2 already existed in the bridge table.
     * @throws Exception In case of any other error
     */
    @Processor
    public void insert(String key1, String key2) throws Exception
    {
        validateKey(getKey1Description(), key1);
        validateKey(getKey2Description(), key2);
        
        this.bridgeTable.insert(getKey1Type().toObject(key1), getKey2Type().toObject(key2));
    }
    
    /**
     * Update or insert the mapping: key1 <=> key2.
     * If key1 already existed in the database, then the value for key2 is updated, if not
     * the mapping will be inserted.
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:upsert-by-key1}
     *
     * @param key1 The value for key1
     * @param key2 The new value for key2
     * @throws KeyAlreadyExistsException If the value for key2 already existed in the bridge table when attempting the insert.
     * @throws Exception In case of any other error
     */
    @Processor
    public void upsertByKey1(String key1, String key2) throws Exception
    {
        validateKey(getKey1Description(), key1);
        validateKey(getKey2Description(), key2);

        try
        {
            this.bridgeTable.updateByKey1(getKey1Type().toObject(key1), getKey2Type().toObject(key2));
        }
        catch(KeyDoesNotExistException ex)
        {
            this.bridgeTable.insert(getKey1Type().toObject(key1), getKey2Type().toObject(key2));
        }
    }

    /**
     * Update or insert the mapping: key2 <=> key1.
     * If key2 already existed in the database, then the value for key1 is updated, if not
     * the mapping will be inserted.
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:upsert-by-key2}
     *
     * @param key1 The new value for key1
     * @param key2 The value for key2
     * @throws KeyAlreadyExistsException If the value for key1 already existed in the bridge table when attempting the insert.
     * @throws Exception In case of any other error
     */    
    @Processor
    public void upsertByKey2(String key1, String key2) throws Exception
    {
        validateKey(getKey1Description(), key1);
        validateKey(getKey2Description(), key2);

        try
        {
            this.bridgeTable.updateByKey2(getKey2Type().toObject(key2), getKey1Type().toObject(key1));
        }
        catch(KeyDoesNotExistException ex)
        {
            this.bridgeTable.insert(getKey1Type().toObject(key1), getKey2Type().toObject(key2));
        }
    }

    /**
     * Update the mapping: key1 <=> key2
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:update-by-key1}
     *
     * @param key1 The value for key1
     * @param newKey2 The new value for key2
     * @throws KeyDoesNotExistException If key1 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public void updateByKey1(String key1, String newKey2) throws Exception
    {
        validateKey(getKey1Description(), key1);
        validateKey(getKey2Description(), newKey2);
        this.bridgeTable.updateByKey1(getKey1Type().toObject(key1), getKey2Type().toObject(newKey2));
    }
    
    /**
     * Update the mapping: key2 <=> key1
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:update-by-key2}
     *
     * @param key2 The value for key2
     * @param newKey1 The new value for key1
     * @throws KeyDoesNotExistException If key2 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public void updateByKey2(String key2, String newKey1) throws Exception
    {
        validateKey(getKey1Description(), newKey1);
        validateKey(getKey2Description(), key2);
        
        this.bridgeTable.updateByKey2(getKey2Type().toObject(key2), getKey1Type().toObject(newKey1));
    }
    
    /**
     * Remove the mapping: key1 <=> key2
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:remove-by-key1}
     *
     * @param key1 The value of key1 to delete
     * @throws KeyDoesNotExistException If key1 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public void removeByKey1(String key1) throws Exception
    {
        validateKey(getKey1Description(), key1);
        
        this.bridgeTable.removeByKey1(getKey1Type().toObject(key1));
    }
    
    /**
     * Remove the mapping: key2 <=> key1
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:remove-by-key2}
     *
     * @param key2 The value of key2 to delete
     * @throws KeyDoesNotExistException If key2 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public void removeByKey2(String key2) throws Exception
    {
        validateKey(getKey2Description(), key2);
        
        this.bridgeTable.removeByKey2(getKey2Type().toObject(key2));
    }
    
    /**
     * Retrieves the value of key2 associated with key1.
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:retrieve-by-key1}
     *
     * @param key1 The value of key1 to retrieve
     * @return Value of key2 (String if <code>returnValueAsString == true</code> or the object corresponding to <code>key2Type</code>)
     * @throws KeyDoesNotExistException If key1 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public Object retrieveByKey1(String key1) throws Exception
    {
        validateKey(getKey1Description(), key1);
        
        Object value = this.bridgeTable.retrieveByKey1(getKey1Type().toObject(key1));
        
        return transformReturnValue(value, getKey2Type());
    }
    
    /**
     * Retrieves the value of key1 associated with key2.
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:retrieve-by-key2}
     *
     * @param key2 The value of key2 to retrieve
     * @return Value of key1 (String if <code>returnValueAsString == true</code> or the object corresponding to <code>key1Type</code>)
     * @throws KeyDoesNotExistException If key2 is not present in the bridge table
     * @throws Exception In case of any other error
     */
    @Processor
    public Object retrieveByKey2(String key2) throws Exception
    {
        validateKey(getKey2Description(), key2);
        
        Object value =  this.bridgeTable.retrieveByKey2(getKey2Type().toObject(key2));
        
        return transformReturnValue(value, getKey1Type());
    }
    
    /**
     * Checks whether key1 exists in the bridge table
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:contains-key1}
     *
     * @param key1 The value of key1 to check
     * @return If the bridge table contains key1
     * @throws Exception In case of error
     */
    @Processor
    public boolean containsKey1(String key1) throws Exception
    {
        validateKey(getKey1Description(), key1);
        
        return this.bridgeTable.containsKey1(getKey1Type().toObject(key1));
    }
    
    /**
     * Checks whether key2 exists in the bridge table
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:contains-key2}
     *
     * @param key2 The value of key2 to check
     * @return If the bridge table contains key2
     * @throws Exception In case of error
     */
    @Processor
    public boolean containsKey2(String key2) throws Exception
    {
        validateKey(getKey2Description(), key2);
        
        return this.bridgeTable.containsKey2(getKey2Type().toObject(key2));
    }
    
    /**
     * Returns all the values for key1
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:keys1}
     *
     * @return A list of key1 objects (String if <code>returnValueAsString == true</code> or the object corresponding to <code>key1Type</code>)
     * @throws Exception In case of error
     */
    @Processor
    public List<Object> keys1() throws Exception
    {
        List<Object> values = this.bridgeTable.keys1();
        
        for(int i=0; i < values.size(); i++)
        {
            values.set(i, transformReturnValue(values.get(i), getKey1Type()));
        }
        
        return values;
    }
    
    /**
     * Returns all the values for key2
     * <p/>
     * {@sample.xml ../../../doc/module-bridgetable-module.xml.sample bridgetable:keys2}
     *
     * @return A list of key2 objects (String if <code>returnValueAsString == true</code> or the object corresponding to <code>key2Type</code>)
     * @throws Exception In case of error
     */
    @Processor
    public List<Object> keys2() throws Exception
    {
        List<Object> values = this.bridgeTable.keys2();
        
        for(int i=0; i < values.size(); i++)
        {
            values.set(i, transformReturnValue(values.get(i), getKey2Type()));
        }
        
        return values;
    }

    public String getTableName()
    {
        return tableName;
    }

    public void setTableName(String tableName)
    {
        this.tableName = tableName;
    }

    public DataSource getDataSource()
    {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource)
    {
        this.dataSource = dataSource;
    }

    public boolean isAutoCreateTable()
    {
        return autoCreateTable;
    }

    public void setAutoCreateTable(boolean autoCreateTable)
    {
        this.autoCreateTable = autoCreateTable;
    }

    public KeyType getKey1Type()
    {
        return key1Type;
    }

    public void setKey1Type(KeyType key1Type)
    {
        this.key1Type = key1Type;
    }

    public KeyType getKey2Type()
    {
        return key2Type;
    }

    public void setKey2Type(KeyType key2Type)
    {
        this.key2Type = key2Type;
    }

    public Type getType()
    {
        return type;
    }

    public void setType(Type type)
    {
        this.type = type;
    }

    public boolean isAllowEmptyKeys()
    {
        return allowEmptyKeys;
    }

    public void setAllowEmptyKeys(boolean allowEmptyKeys)
    {
        this.allowEmptyKeys = allowEmptyKeys;
    }
    
    /*
     * Validates keys sent as parameters
     */
    private void validateKey(String keyName, String keyValue)
    {
        if(!isAllowEmptyKeys() && StringUtils.isEmpty(keyValue))
        {
            String msg = "Empty keys are not allow for " + keyName + ".";
            LOGGER.error(msg);
            throw new IllegalArgumentException(msg);
        }
    }

    /*
     * Transform return values
     */
    private Object transformReturnValue(Object value, KeyType type)
    {
        if(isReturnValueAsString())
        {
            return KeyType.STRING.fromObject(value); 
        }
        else
        {
            return type.fromObject(value);
        }        
    }
    
    private String getKey1Description()
    {
        return "key1 (" + getKey1Name() + ")";
    }
    
    private String getKey2Description()
    {
        return "key2 (" + getKey2Name() + ")";
    }

    public String getKey1Name()
    {
        return key1Name;
    }

    public void setKey1Name(String key1Name)
    {
        this.key1Name = key1Name;
    }

    public String getKey2Name()
    {
        return key2Name;
    }

    public void setKey2Name(String key2Name)
    {
        this.key2Name = key2Name;
    }    
    
    public boolean isReturnValueAsString()
    {
        return returnValueAsString;
    }

    public void setReturnValueAsString(boolean returnValueAsString)
    {
        this.returnValueAsString = returnValueAsString;
    }
    
}
